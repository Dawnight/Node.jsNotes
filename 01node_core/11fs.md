# `fs`文件系统
> 在`Node.js`中，提供一个`fs`模块，以实现文件及目录的读写操作。
## 1. 同步和异步方法
> 一般来讲，读取文件使用异步的方法，但是在读取例如系统配置文件时，应该使用同步的方法

## 2. 普通文件写入和读取

### 2.1 文件写入

#### 2.1.1 写入一个基本的文本文件
+ 如果不存在要写入的文件，那么将会自动创建一个文件
```javascript
const fs = require('fs');
let writeData = 'The engaged couple will appear for a photo outside Kensington Palace on Monday afternoon, and will take part in a broadcast interview in the evening.';
fs.writeFile('./writeFile.txt', writeData, 'utf-8', function (err) {
	if (err) {
		console.log('there are some wrong happened~');
	} else {
		console.log('Write successfully~~');
	}
});
```

### 2.1.2 复制图片及各种二进制文件(以图片文件为例)
+ 当前文件夹下有一个`fileImage.jpg`的图片文件
```javascript
const fs = require('fs');
fs.readFile('./fileImage.jpg', 'base64', function (err, data) {
	if (err) {
		console.log('读取图片失败，请检查错误');
	} else {
		fs.writeFile('./fileImageCopy.jpg', data, 'base64', function (err) {
			if (err) {
				console.log('复制图片文件失败');
			} else {
				console.log('复制图片文件成功');
			}
		});
	}
});
```

### 2.2 文件读取
#### 2.2.1 文件同步读取
> 当前目录下有一个`readFile.txt`文件，文件的内容是`hello, this is a read file txt.`
```javascript
const fs = require('fs');
fs.readFile('./readFile.txt', 'utf-8', function(err, data){
	if (err) {
		console.log('read file wrong', err);
	} else {
		console.log('dataAsync');
		console.log(data);
	}
});
/**
 * dataAsync
 * hello, this is a read file txt.
 * **/
```

#### 2.2.2 文件异步读取
```javascript
const fs = require('fs');
let dataSync = fs.readFileSync('./readFile.txt', 'utf-8');
console.log('dataSync');
console.log(dataSync);
/**
 * dataSync
 * hello, this is a read file txt.
 * **/
```

## 3. 追加数据

### 3.1 对文本文件同步追加数据
```javascript
const fs = require('fs');
const appendFileContent = 'this is appendFileContent box';
fs.appendFileSync('./appendFile.txt', appendFileContent, 'utf-8');
```
### 3.2 对文本文件异步追加数据
+ `appendFile.txt`原本内容
```txt
hello, this a basic append txt file.

-
```
```javascript
const fs = require('fs');
const appendFileContent = 'this is appendFileContent box';
fs.appendFile('./appendFile.txt', appendFileContent, 'utf-8', function (err) {
	if (err) {
		console.log('追加文件操作失败');
	} else {
		fs.readFile('./appendFile.txt', 'utf-8', function (err, data) {
			if (err) {
				console.log('追加成功，但是读取失败');
			} else {
				console.log('追加成功，读取操作成功');
				console.log(data);
			}
		});
	}
});
/**
* 追加成功，读取操作成功
* hello, this a basic append txt file.
* 
* -this is appendFileContent box 
* **/
```

## 4. 文件的打开和关闭
> `fd`代表打开文件时返回的文件描述符，在`windows`操作系统中，文件描述符也称为文件句柄。

#### 4.1 同步打开文件
```javascript
const fs = require('fs');
fs.open('./openFile.txt', 'r', (err, fd) => {
    if (err) {
        console.log('open file wrong', err);
    } else {
        console.log('open');
		console.log(fd);.
		fs.close(fd); // 同步关闭文件
    }
});
/**
* open
* 3
* **/
```

#### 4.1 异步打开文件
```javascript
const fs = require('fs');
let openSync = fs.openSync('./openFile.txt', 'r');
console.log('openSync');
console.log(fd);
fs.clodeSync(fd); // 异步关闭文件
/**
* openSync
* 3
* **/
```

## 5. `fs`的`fs.write`和`fs.read`
+ 在使用`write`方法或者`writeSync`方法在文件中写入数据时
+ 操作系统的做法是首先将该部分数据读取到内存中,再把数据写到文件中
+ 当数据读取完毕时不代表数据已经写完,因为还有一步部分可能会留在内存缓冲区中.
+ 这时候如果调用`close`或者`closeSync`方法关闭文件,那么这部分数据就会丢失,
+ 这时候就可以采用`fs`模块中的`fsync`方法对文件进行同步操作,即将内存缓冲区中的剩余数据全部写入文件.

### 5.1 文件写入
+ 当前目录下有一个`write.txt`文件，文件的内容是`我喜欢编程` 
#### 5.1.1 同步写入
+ 更加底层的一种写入方法，可以从指定位置写入数据
+ 用`fs.write`写入，需要先打开文件，根据文件资源句柄，写入内容
+ `fs.write(fd, buffer, offset, length, position, callback(err, written, buffer))`
```javascript
const fs = require('fs');
let buf = new Buffer('我喜欢编程');
fs.open('./write.txt', 'w', function (err, fd) {
    if (err) {
        console.log('open file wrong', err);
    } else {
        fs.write(fd, buf, 3, 9, 0, function (err, written, buffer) {
            if (err) {
                console.log('写文件操作失败');
            } else {
				console.log('写文件操作成功');
				console.log(buffer.toString());
            }
        });
    }
});
/**
 * 写文件操作成功
 * 我喜欢编程
 * **/
```

#### 5.1.2 异步写入
+ `fs.writeSync(fd, buffer, offset, length, position)`
```javascript
const fs = require('fs');
let buf = new Buffer('我喜欢编程');
fs.open('./write.txt', 'w', function (err, fd) {
    if (err) {
        console.log('open file wrong', err);
    } else {
        fs.writeSync(fd, buf, 3, 9, 0);
    }
});
```

### 5.2 文件读取
+ 当前目录下有一个`open.txt`文件，文件的内容是`我喜欢编程` 
#### 5.2.1 同步读取
+ `fs.readSync(fd, buffer, offset, length, position, callback)`
```javascript
const fs = require('fs');
 fs.open('./open.txt', 'r', function(err, fd){
	var buf = new Buffer(255).fill(0);
	var bytesRead = fs.readSync(fd, buf, 0, 9, 3);
	console.log(bytesRead);//9
	console.log(buf.slice(0, bytesRead).toString());//喜欢编
});
```

#### 5.2.2 异步读取
+ `fs.read(fd, buffer, offset, length, position, callback(err,bytesRead, buffer))`
```javascript
const fs = require('fs');
fs.open('./open.txt', 'r', function (err, fd) {
    let buf = new Buffer(255).fill(0);//缓存区
    fs.read(fd, buf, 0, 9, 3, function (err, bytesRead, buffer) {
        console.log(buffer.slice(0, bytesRead).toString());//喜欢编
    });
});

fs.open('./open.txt', 'r', function (err, fd) {
    let buf = new Buffer(255).fill(0);//缓存区
    fs.read(fd, buf, 0, 9, 3, function (err, bytesRead, buffer) {
        console.log(buffer.slice(0, bytesRead).toString());//喜欢编
        fs.read(fd, buf, 0, 3, null, function (err, bytesRead, buffer) {
            console.log(buffer.slice(0, bytesRead).toString());//程
        });
    });
});
```

## 6. 目录操作
### 6.1 创建目录
+ 如果存在该目录，就创建失败
+ 同步创建目录`fs.mkdirSync(path, [mode])`
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.mkdir(mkdir, (err) => {
    if (err) {
        console.log(`mkdir ${mkdir} file failed~`);
    } else {
        console.log(`mkdir ${mkdir} file success~`);
    }
});
```
### 6.2 读取目录
+ 如果读取的目录下有子目录或子文件，将会把子目录或子文件的文件名作为`files`的数组元素
+ 同步读取目录`fs.readdirSync()`
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.mkdir(mkdir, (err) => {
    if (err) {
        console.log(`mkdir ${mkdir} file failed~`);
        return false;
    }
    console.log(`mkdir ${mkdir} file success~`);
    let fileName = ['ONE', 'TWO', 'THREE'];
    fileName.forEach((elem) => {
        fs.mkdir(`${mkdir}/${elem}`, (err) => {
            if (err) {
                console.log(`${mkdir}/${elem} failed~`);
                return false;
            }
        });
        fs.readdir(mkdir, (err, files) => {
            if (err) {
                console.log(`readdir ${mkdir} file failed~`);
                return false;
            }
            console.log(`readdir ${mkdir} file success~`);
            console.log(`${files}`);
        });
    });
});
```
## 7. 查看与修改文件或目录信息
+ 在`fs`模块中,可以使用`stat`方法或者`lstat`方法查看一个文件或一个目录。唯一区别在于当查看符号链接文件的信息时,必须使用`lstat`方法。
+ `fs.stat(path, callback(err, stats))`
+ `fs.lstat(path, callback(err, stats))`

### 7.1 查看文件信息
+ 同步方法查看文件信息`fs.statSync(path);`
```javascript
const fs = require('fs');
let mkdir = './mkdir';

fs.stat(mkdir, (err, stats) => {
    if (err) {
        console.log(`fs.stats ${mkdir} file failed~`);
    } else {
        console.log(`fs.stats ${mkdir} file success~`);
        console.log(stats);
    }
});
```
+ `stats`详解
```
Stats {
  dev: 2050,文件或目录所在的设备ID,仅在UNIX有效
  mode: 16877,使用数值形式代表的文件或目录的权限标志
  nlink: 3,文件或目录的硬连接数量
  uid: 0,文件或目录的所有者的用户ID,仅在UNIX有效
  gid: 0,文件或目录的所有者的用户组ID,仅在UNIX有效
  rdev: 0,为字符设备文件或块设备文件所在设备ID,仅在UNIX有效
  blksize: 4096,
  ino: 4197533,文件或目录的索引编号,仅在UNIX有效
  size: 4096,文件尺寸,即文件中的字节数
  blocks: 8,
  atimeMs: 1511846425357.986,
  mtimeMs: 1511846425256.986,
  ctimeMs: 1511846425256.986,
  birthtimeMs: 1511846425256.986,
  atime: 2017-11-28T05:20:25.358Z,文件的访问时间
  mtime: 2017-11-28T05:20:25.257Z,文件的修改时间
  ctime: 2017-11-28T05:20:25.257Z,文件的创建时间
  birthtime: 2017-11-28T05:20:25.257Z 
}
```
### 7.2 `fstat`方法查询文件信息
+ 使用`open`方法或`openSync`方法打开文件并返回文件描述符时，可以使用`fs`模块中的`fstat`方法查询被打开的文件信息
```javascript
const fs = require('fs');
let mkdir = './mkdir';

fs.open(mkdir, 'r', (err, fd) => {
    if (err) {
        console.log(`open ${mkdir} file failed~`);
        return false;
    }
    fs.fstat(fd, (err, stats) => {
        if (err) {
            console.log(`fstat ${mkdir} file failed~`);
            return false;
        }
        console.log(JSON.stringify(stats));
    })
})
```
+ `fs.fstat`结果
```
{
    "dev": 1041887651,
    "mode": 16822,
    "nlink": 1,
    "uid": 0,
    "gid": 0,
    "rdev": 0,
    "ino": 4222124650663107,
    "size": 0,
    "atimeMs": 1519394418412.3062,
    "mtimeMs": 1519394418412.3062,
    "ctimeMs": 1519394418412.3062,
    "birthtimeMs": 1519394418402.2554,
    "atime": "2018-02-23T14:00:18.412Z",
    "mtime": "2018-02-23T14:00:18.412Z",
    "ctime": "2018-02-23T14:00:18.412Z",
    "birthtime": "2018-02-23T14:00:18.402Z"
}
```
### 7.3 检查文件或目录是否存在
+ 参数为`boolean`类型的值
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.exists(mkdir, (exits) => {
    if (exits) {
        console.log(`${exits}, ${mkdir} file exists`);
    } else {
        console.log(`${exits}, ${mkdir} file not exists`)
    }
});
```

### 7.4 修改文件访问时间及修改时间
+ `fs.utimes(path, atime, mtime, callback(err))`
+ 同步修改文件访问时间及修改时间`fs.utimesSync(path, atime, mtime)`
```javascript
// 修改文件访问时间及修改时间都为当前时间
const fs = require('fs');
let mkdir = './mkdir';
fs.utimes(mkdir, new Date(), new Date(), (err) => {
    if (err) {
        console.log(`fs.utimes ${mkdir} file failed~`);
    } else {
        console.log(`fs.utimes ${mkdir} file success~`);
    }
})
```

### 7.5 修改文件或目录的权限
+ 同步修改文件或目录的权限`fs.chmodSync(path, mode);`
+ `fs.chmod(path, mode, callback(err))`
+ `mode`代表的是权限的大小
+ `fs.chmod`方法触发前的权限是`drwxr-xr-x.`
+ `fs.chmod`方法触发后的权限是`drw-------.`
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.chmod(mkdirOne, '0600', (err) => {
    if (err) {
        console.log(`fs.chmod ${mkdir} file failed`);
        return false;
    }
    console.log(`fs.chmod ${mkdir} file success~`);
});
```
+ 在使用`open`方法或`openSync`方法打开文件并返回文件描述符之后，可以使用`fs`模块中的`fchmod`方法修改文件的读写权限
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.open(mkdir, 'r', (err, fd) => {
    if (err) {
        console.log(`open file ${mkdir} failed~`);
        return false;
    }
    fs.fchmod(fd, '0600', (err) => {
        if (err) {
            console.log(`fs.fchmod ${mkdir} file failed~`);
            return false;
        }
        console.log(`fs.fchmod ${mkdir} file success~`);
    })
});
```

## 8. 对文件或目录执行的其他操作
### 8.1 修改文件名字或移动文件目录`fs.rename`
+ `fs.rename(oldPath, newPath, callback(err))`
+ 使用`rename`方法移动文件或目录,当移动后的路径与原路经为同一路径,则修改该文件的名字
+ 若移动后的文件名或目录名与原文件名或目录名不同时，则执行文件或目录的移动操作
```javascript
const fs = require('fs');
let mkdir = './mkdir';
fs.rename('./one', './two', (err) => {
    if (err) {
        console.log(`fs.rename file one to two failed~`);
        return false;
    }
    console.log(`fs.rename file one to two success~`);
})
```

### 8.2 创建文件的硬链接`fs.link`
+ `fs.link(oldPath, newPath)`
+ `srcPath`参数用于指定需要被创建硬链接的文件的完整路径及文件名
+ `dstPath`参数用于指定被创建硬链接的完整路径及文件名，该硬连接与源文件必须位于同一卷中
+ 异步创建与删除文件的硬链接`fs.linkSync(srcPath, dstPath)`
```javascript
const fs = require('fs');
let linkFile = 'link.txt';
let linkCopyFile = 'linkCopy.txt';
let data = '创建与删除文件的硬链接';
fs.writeFile('./link.txt', data, (err) => {
    if (err) {
        console.log(`write file failed`);
        return false;
    }
    fs.link(linkFile, linkCopyFile, (err) => {
        if (err) {
            console.log(`fs.link ${linkFile} file failed~`);
            return false;
        }
        console.log(`fs.link ${linkCopyFile} file success~`);
    });
});
```

### 8.3 删除文件的硬链接`fs.unlink`
+ `fs.unlink(path, callback(err))`
```javascript
const fs = require('fs');
let linkFile = 'link.txt';
let linkCopyFile = 'linkCopy.txt';
let data = '创建与删除文件的硬链接';
fs.unlink(linkCopyFile, (err) => {
    if (err) {
        console.log(`fs.unlink ${linkFile} file failed~`);
        return false;
    }
    console.log(`fs.unlink ${linkCopyFile} file success~`);
})
```
### 8.4 创建与查看符号链接
> 符号链接，是一种特殊的文件，这个文件中仅包含了另一个文件或目录的路径及文件名或目录名。如果打开一个文件的符号链接文件进行编辑，操作系统将自动打开符号链接中所指向的原文件进行编辑，如果打开一个目录的符号链接文件进行文件的操作编辑或删除操作，则操作系统将西东打开符号链接中所指向的原目录并执行相应的操作。如果删除符号链接文件，不会删除原文件或目录，如果删除或移动原文件互哦目录，符号链接文件也不会被删除，这是会产生一种称为`断链`的现象

+ `fs.symlink(srcPath, dstPath, [type], callback(err))`
+ `type--> file, dir(default,非windows只能使用dir), function(only windows)`
+ 同步创建与查看符号链接`fs.symlinkSync(srcPath, dstPath, [type])`
```javascript
const fs = require('fs');
fs.symlink('./one.js', './two.js', 'file', (err) =>{
    if(err) {
        console.log(`fs.symlink one.js to two.js failed~`, err);
        return false;
    } 
    console.log(`fs.symlink one.js to two.js success~`)
})
```
### 8.5 `readlink`读取符号链接
+ 同步读取符号链接`fs.readlinkSync(path)`，`path`指定符号链接的路径及文件名
```javascript
const fs = require('fs');
fs.symlink('./one.js', './two.js', 'file', (err) => {
    if (err) {
        console.log(`fs.symlink one.js to two.js failed~`, err);
        return false;
    }
    console.log(`fs.symlink one.js to two.js success~`);
    fs.readlink('./two.js', (err, linkString) => {
        if (err) {
            console.log(`fs.readlink file failed~`, err);
            return false;
        }
        console.log(linkString);
    })
});
/**
* fs.symlink one.js to two.js success~
* ./one.js
* **/
```

### 8.6 截断文件`fs.truncate()`
+ 所谓对文件进行截断操作，是指一种首先清除文件内容，然后修改文件尺寸的操作
+ 换句话说就是对文件内容进行修改
+ `fs.truncate(filename, length, callback(err))`
+ 同步截断文件`fs.truncateSync(filename, length)`
+ `one.js`原本内容
```javascript
console.log('this is one.js');
```
+ 对`one.js`文件进行截断
```javascript
const fs = require('fs');
fs.truncate('./one.js', 10, (err) => {
    if (err) {
        console.log(`对文件进行截断操作失败~, ${err}`);
        return false;
    }
    fs.stat('./one.js', (err, stats) => {
        if (err) {
            console.log(`fs.stat file one.js failed, ${err}`);
            return false;
        }
        console.log(`fs.stat file one.js success~`);
        console.log(`./one.js size: ${stats.size} bytes`);
    });
});
/**
* console.lo
* **/
```

### 8.7 删除空目录
+ 只能删除空目录，如果不是空目录，会删除失败
```javascript
const fs = require('fs');
fs.rmdir('./dirOne', (err) => {
    if (err) {
        console.log(`fs.rmdir dir one failed~, ${err}`);
        return false;
    }
    console.log(`fs.rmdir dir one success~`);
});
```

### 8.8 监视文件或目录
+ 使用`watchFile`方法对文件进行监视，并且在监视到文件被修改时执行某些处理方法
+ `fs.watchFile(filename, [options], listener)`
+ `options` 是一个对象，`persistent`属性默认为`true`，所以当监视文件后，应用程序没有被立即退出，改为`false`就会立即退出。
+ `options interval`属性方法设置每隔多少毫秒检查一下该文件有没有发生变化
+ `function(curr, prev);`,`curr`是`fs.Stats`对象，代表被修改之后的当前文件
+ `prev`参数值也是一个`fs.Stats`对象，代表被修改之前的当前文件
```javascript
const fs = require('fs');
let filename = './one.js'
fs.watchFile(filename, {
    persistent: true,
    interval: 100
}, (curr, prev) => {
    if (Date.parse(prev.ctime) === 0) {
        console.log(`${filename}文件被创建`);
    } else if (Date.parse(curr.ctime) === 0) {
        console.log(`${filename}文件被删除`);
    } else if (Date.parse(prev.mtime) !== Date.parse(curr.mtime)) {
        console.log(`${filename}文件被修改`);
    } else {
        console.log(`${filename}文件没有被操作`);
    }
    if (Date.parse(curr.ctime) !== 0) {
        console.log(`${filename}文件的大小为${curr.size}bytes`);
    }
})
```

### 8.9 取消监控
+ `fs.unwatchFile(filename, [listener])`
+ `watch`方法，对文件或目录进行监视，并且在监视到文件或目录被修改时执行某些处理
+ `fs.watch(filename, [options], [listener])`
```javascript
var watcher = fs.watch('./file01.txt', function (event, filename) {
	console.log(event);//事件名
	console.log(filename);//文件名
	watcher.close();//关闭监视
});
```
## 9. `stream`流
+ fs模块中集中文件读写方法的区别

|用途 |使用异步方式|使用同步方式|
| -------- | -----: | :----: |
|将文件完整读入缓存区|readFile|readFileSync|
|将文件部分读入缓存区|read|readSync|
|将数据完整写入文件 |writeFile|writeFileSync|
|将缓存区中的部分内容写入文件|write|writeSync|

> 在使用`readFile`或者`readFileSync`读取文件内容时，Node.js首先将文件内容完整地读入缓存区，再从缓存区中读取文件内容。在使用`writeFile`或者`writeFileSync`方法写入文件内容时，Node.js首先将该文件内容读入缓存区，然后一次性将缓存区中内容写入到文件中。也就是说，在使用`readFile`或者readFileSync`读取文件内容或者使用`writeFile`或者`writeFileSync`写入文件内容时，Node.js会将该文件内容视为一个整体，为其分配缓存区并且一次性将文件内容读取到缓存区。在这期间，Node.js不再执行任何其他处理。

> 如果使用`read`或者`readSync`方法读取文件内容，Node.js将不断地将文件中一小块内容读入缓存区，最后从缓存区中读取文件内容，如果使用`write`或者`writeSync`写入文件内，Node.js将实行以下过程：1.将需要书写的数据书写到一个内容缓冲区；2. 待缓冲区写满后再讲该缓冲区中内容写入到文件中；3. 重复执行过程1和过程2，直到数据全部写入文件为止。也就是说，如果使用`read`或者`readSync`读取文件内容或者使用`write`或者`writeSync`写入文件，在读写文件过程中允许Node.js执行其他操作。

+ `流`的概念
> 在一个应用程序中，流是一组有序的，有起点和终点的字节数据的传输手段。在应用程序中各种对象之间交换与传输数据的时候，总是先将对象中所包含的数据转换为各种形式的流数据(字节数据)，再通过流的传输，到达目的对象后再将流数据转换为该对象中可以使用的数据。

> 在Node.js中，使用各种实现了`stream.Readable`接口的对象来讲对象数据读取为流数据，所有这些对象都是继承了`EventEmitter`类的实例对象，在读取数据的过程中，将可能触发各种事件。

> 在Node.js中，可以使用`flowing`模式与非`flowing`模式来读取数据，当使用`flowing`模式时，将使用操作系统的内部`I/O`机制来读取数据。这将允许你以最快的速度来读取数据。当使用非`flowing`模式时，必须显式调用对象的`read`方法来读取数据。

+ Node.js中各种用于读取数据的对象

|对象 |描述|
| -------- | -----: |
|fs.ReadStream|用于读取文件|
|http.IncomingMessage|代表客户端请求或服务器端响应|
|net.Socket |代表一个socket端口对象|
|child.stdout|用于创建子进程的标准输出流。如果子进程和父进程共享输入输出流，则子进程的标准输出流被废弃|
|child.stderr|用于创建子进程的标准错误输出流。如果子进程和父进程共享输入输出流，则子进程的标准错误输出流被废弃|
|process.stdin|用于创建进程的标准输入流|
|Gzip,Deflate,DeflatRaw| 用于实现数据压缩|

### 9.1 使用`ReadStream`对象读取文件
+ `fs.createReadStream(path, [options])`
+ `options`参数
	* `flags`: 'r',//default,
	* `encoding`: 'utf8', //base64, ascii, null(default),
	* `autoClose`: true(default), //false
	* `start`: 使用整数值来指定文件的开始读取位置		
	* `end`: 使用整数值来指定文件的结束读取位置
```javascript
const fs = require('fs');
let filename = './one.js'
let file = fs.createReadStream(filename, {
    start: 0,
    end: 100,
    encoding: 'utf8'
});

file.on('open', (fd) => {
    console.log('open file and start read this file stream..');
});

file.pause(); // 暂停读取文件流

file.on('data', (data) => {
    console.log(`读取到文件内容, ${data}`);
});

file.resume(); // 恢复读取文件流

file.on('end', () => {
    console.log('文件读取结束');
});

file.on('close', () => {
    console.log('文件关闭');
});

file.on('error', (err) => {
    console.log(`文件读取错误, ${err}`);
});
/***
 * open file and start read this file stream..
 * 读取到文件内容, hello
 * 文件读取结束
 * 文件关闭
 */
```

### 9.2 使用`WriteStream`对象写入文件
+ `fs.createWriteStream(path, [options])`
```javascript
const fs = require('fs');
let readFilename = './readFilename.js';
let writeFileName = './writeFileName.js';
let readFile = fs.createReadStream(readFilename, {
    start: 0,
    end: 100,
    encoding: 'utf8'
});
let writeFile = fs.createWriteStream(writeFileName);
readFile.on('data', (data) => {
    writeFile.write(data, () => {
        console.log('write writeFileName.js');
        console.log(data);
    })
});

readFile.on('open', (fd) => {
    console.log(`open readFilename.js`);
});

readFile.on('end', () => {
    writeFile.end('byebye', () => {
        console.log('writeFile.js end');
        console.log(`${writeFile.bytesWritten}`)
    });
});
/***
 * open readFilename.js
 * write writeFileName.js
 * console.log('this is readFilename.js');
 * writeFile.js end
 * 45 
 */
```































